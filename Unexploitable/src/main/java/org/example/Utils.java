package org.example;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;

public class Utils {
    private static final Logger LOG = LoggerFactory.getLogger(Utils.class);


    private static String[] deck = {
            "As", "Ah", "Ad", "Ac",
            "2s", "2h", "2d", "2c",
            "3s", "3h", "3d", "3c",
            "4s", "4h", "4d", "4c",
            "5s", "5h", "5d", "5c",
            "6s", "6h", "6d", "6c",
            "7s", "7h", "7d", "7c",
            "8s", "8h", "8d", "8c",
            "9s", "9h", "9d", "9c",
            "Ts", "Th", "Td", "Tc",
            "Js", "Jh", "Jd", "Jc",
            "Qs", "Qh", "Qd", "Qc",
            "Ks", "Kh", "Kd", "Kc"
    };




    public static void generateFlop(String hand){
        Random r = new Random();
        String[] flop = new String[3];
        flop[0]=deck[r.nextInt(deck.length)];
        boolean doLoop = true;

        while( Objects.equals(flop[0], flop[1]) || checkCardInHand(hand,flop[1]) || doLoop){
            flop[1]=deck[r.nextInt(deck.length)];
            doLoop=false;
        }

        doLoop=true;
        while(Objects.equals(flop[0], flop[2]) || Objects.equals(flop[1], flop[2]) || checkCardInHand(hand,flop[2]) || doLoop){
            flop[2]=deck[r.nextInt(deck.length)];
            doLoop=false;
        }

        LOG.info("Hero hand : {} {} ", hand.substring(0,2),hand.substring(2,4));
        LOG.info("generato flop : {} {} {}",flop[0],flop[1],flop[2]);
    }








    public static boolean isFullHouse(String[] board, String[] hand){
        LOG.info("Check if {} {} made a FullHouse on {} {} {} {} {} ",hand[0],hand[1],board[0],board[1],board[2],board[3],board[4]);

       if(handIsAPair(hand)){
           if(boardContainThatCard(board,hand) && boardIsOnlyPaired(board)) {
               LOG.info("fullHouse | perche la mano è una pair che fa un set col board e il board è pairato");
               return true;
           }else if (!boardContainThatCard(board,hand) && boardIsOnlyTripsed(board)){
               LOG.info("fullHouse | perche la mano è una pair e il board è tripsed");
               return true;
           }
       }else{
           // la mano che abbiamo non è una pair quindi
           //   board tripsed + una delle carte della mano che fa pair
           //   1 carta della mano fa trips e l'altra fa pair
               if(boardIsOnlyTripsed(board) && boardContainThatCard(board,hand)){
                   for(String card : hand){
                    if(cardMakeAPairWithBoard(board,card)) {
                        LOG.info("fullHouse | perche il board è tripsed e una delle due carte in mano forma una pair con il board");
                        return true;
                    }
                   }
               }

               if(boardIsOnlyPaired(board)){
                 if(cardMakeATripsWithBoard(board,hand[0]) && cardMakeAPairWithBoard(board,hand[1])){
                     LOG.info("FULLHOUSE | {} forma un trips con il board e {} forma una coppia con il board {} {} {} {} {} ",hand[0],hand[1],board[0],board[1],board[2],board[3],board[4]);
                     return true;
                 }
                 if(cardMakeATripsWithBoard(board,hand[1]) && cardMakeAPairWithBoard(board,hand[0])){
                     LOG.info("FULLHOUSE | {} forma un trips con il board e {} forma una coppia con il board {} {} {} {} {} ",hand[1],hand[0],board[0],board[1],board[2],board[3],board[4]);
                     return true;
                 }
               }
           if(isFullHouseBoard(board)) {
               LOG.info("fullHouse | perche il board è un fullHouseBoard");
               return true;
           }

       }
        LOG.info("{} {} NON formano un fullHouse su questo board {} {} {} {} {}",hand[0],hand[1],board[0],board[1],board[2],board[3],board[4]);
        return false;
    }


    public static boolean isFlush(String[] board , String[] hand){
        String[] semi = new String[]{"s","h","c","d"};
        for(String seme : semi){
            int count=0;
            for(String cardOfBoard : board){
                if(seme.equalsIgnoreCase(cardOfBoard.substring(1,2))) count++;
            }
            for(String cardOfHand : hand){
                if(seme.equalsIgnoreCase(cardOfHand.substring(1,2))) count++;
            }
            if(count>4) {
                LOG.info("FLUSH | {} {} formano un flush su questo board {} {} {} {} {}",hand[0],hand[1],board[0],board[1],board[2],board[3],board[4]);
                return true;
            }
        }
        LOG.info("{} {} NON formano un flush su questo board {} {} {} {} {}",hand[0],hand[1],board[0],board[1],board[2],board[3],board[4]);
        return false;
    }

    public static boolean isStraight(String[] board, String[] hand){
      String[] newBoard = sortBoardPlusHand(board,hand);
      int count;
      for(int i=0 ; i<newBoard.length-4 ; i++){
              if(returnNumber(newBoard[i])-returnNumber(newBoard[i+4])==4) {
                  LOG.info("STRAIGHT | la mano {} forma scala con il board {} ",hand,board);
                  return true;
              }
      }
      if(boardContainThatCard(newBoard,new String[]{"As"})){
          newBoard=sortBoardALow(newBoard);
          for(int i=0 ; i<newBoard.length-4 ; i++){
              if(returnNumberALow(newBoard[i])-returnNumberALow(newBoard[i+4])==4) {
                  LOG.info("STRAIGHT | la mano {} forma scala con il board {} ",hand,board);
                  return true;
              }
          }
      }
        LOG.info("La mano {} NON forma scala con il board {} ",hand,board);
      return false;
    }

    public static String[] calculateMaxValueOnBoard(String[] board, String[] hand){
        if(isFullHouse(board,hand)){
           return getBoardWithOnlyFullHouse(sortBoardPlusHand(board,hand));
        }
        if(isFlush(board,hand)) {
            return getBoardWithOnlyFlush(sortBoardPlusHand(board,hand));
        }
        //if()
        return new String[1];
    }























    public static String[] getBoardWithOnlyFlush (String[] board){
        String symbol = checkSymbolOfSuitness(board);
        String[] boardWithOnlyFlush = new String[5];
        int pos=0;
        for(String cardOfBoard : sortBoard(board)){
           if(symbol.equalsIgnoreCase(cardOfBoard.substring(1,2))){
               boardWithOnlyFlush[pos]=cardOfBoard;
               pos++;
           }
        }
        LOG.info("board con solo carte del seme {} : {} ",symbol,sortBoard(boardWithOnlyFlush));
        return sortBoard(boardWithOnlyFlush);
    }

    public static String[] getBoardWithOnlyFullHouse(String[] board) {
        LOG.info("devo estrarre fullHouse da questo board {} ",board);
        String[] trips = new String[3];
        String[] pair = new String[2];
        String[] sortedBoard = sortBoard(board);
        String[] finalBoard = new String[5];
        for (int i = 0; i < sortedBoard.length - 2; i++) {
            if (returnNumber(sortedBoard[i]) == returnNumber(sortedBoard[i + 1]) && returnNumber(sortedBoard[i + 1]) == returnNumber(sortedBoard[i + 2])) {
                for (int k = 0; k < 3; k++) {
                    finalBoard[k] = sortedBoard[i + k];
                }
            }
        }
        for (int i = 0; i < sortedBoard.length - 1; i++) {
            if (returnNumber(sortedBoard[i]) == returnNumber(sortedBoard[i + 1]) && !boardContainThatCard(finalBoard,new String[]{sortedBoard[i],sortedBoard[i+1]})) {
                int pos=0;
                for (int k = 3; k < 5; k++) {
                    finalBoard[k] = sortedBoard[i+pos];
                    pos++;
                }
            }

        }
        LOG.info("Il board finale con FullHouse è {} {} {} {} {}",finalBoard);
        return finalBoard;
    }


    public static String checkSymbolOfSuitness(String[] board){
        String[] symbols = new String[]{"s","h","c","d"};
        int count;
        for(String symbol : symbols){
            count=0;
            for(String cardOfBoard : board){
                if(symbol.equalsIgnoreCase(cardOfBoard.substring(1,2))) count++;
            }
            if(count>4) {
                LOG.info("il board {} ha come seme {}", board,symbol);
                return symbol;
            }
        }
        return "";
    }

    public static boolean checkCardInHand(String hand , String card){
        String firsthandCard = hand.substring(0,2);
        String secondHandCard = hand.substring(2,4);
        return (Objects.equals(firsthandCard, card) || Objects.equals(secondHandCard, card));
    }


    public static String[] sortBoard (String[] board){
        String[] sortedBoard  = new String[board.length];
        Integer[] arrayofInt = new Integer[board.length];
        for(int i=0 ; i<board.length ; i++){
            arrayofInt[i]=returnNumber(board[i]);
        }
        Arrays.sort(arrayofInt, Collections.reverseOrder());
        int k=0;
        boolean isAlreadyPresent;
        while(k<board.length){
            for(Integer number : arrayofInt){
                for(String cardOfBoard : board){
                    if(number==returnNumber(cardOfBoard)){
                        isAlreadyPresent=false;
                        for(String cardOfSortedBoard : sortedBoard ){
                            if(cardOfSortedBoard!=null && returnNumber(cardOfBoard)==returnNumber(cardOfSortedBoard) &&
                                    cardOfSortedBoard.substring(1,2).equalsIgnoreCase(cardOfBoard.substring(1,2))) isAlreadyPresent=true;
                        }
                        if(!isAlreadyPresent) {
                            sortedBoard[k]=cardOfBoard;
                            LOG.info("carta {} aggiunta al board",cardOfBoard);
                            k++;
                        }
                    }
                }
            }
        }
        if(sortedBoard.length==5) LOG.info("board sorted {} {} {} {} {}",sortedBoard[0],sortedBoard[1],sortedBoard[2],sortedBoard[3],sortedBoard[4]);
        if(sortedBoard.length==6) LOG.info("board sorted {} {} {} {} {} {}",sortedBoard[0],sortedBoard[1],sortedBoard[2],sortedBoard[3],sortedBoard[4],sortedBoard[5]);
        if(sortedBoard.length==7) LOG.info("board sorted {} {} {} {} {} {} {}",sortedBoard[0],sortedBoard[1],sortedBoard[2],sortedBoard[3],sortedBoard[4],sortedBoard[5],sortedBoard[6]);
        return sortedBoard;
    }

    public static String[] sortBoardALow (String[] board){
        String[] sortedBoard  = new String[board.length];
        Integer[] arrayofInt = new Integer[board.length];
        for(int i=0 ; i<board.length ; i++){
            arrayofInt[i]=returnNumberALow(board[i]);
        }
        Arrays.sort(arrayofInt, Collections.reverseOrder());
        int k=0;
        boolean isAlreadyPresent;
        while(k<board.length){
            for(Integer number : arrayofInt){
                for(String cardOfBoard : board){
                    if(number==returnNumberALow(cardOfBoard)){
                        isAlreadyPresent=false;
                        for(String cardOfSortedBoard : sortedBoard ){
                            if(cardOfSortedBoard!=null && returnNumberALow(cardOfBoard)==returnNumberALow(cardOfSortedBoard) &&
                                    cardOfSortedBoard.substring(1,2).equalsIgnoreCase(cardOfBoard.substring(1,2))) isAlreadyPresent=true;
                        }
                        if(!isAlreadyPresent) {
                            sortedBoard[k]=cardOfBoard;
                            LOG.info("carta {} aggiunta al board",cardOfBoard);
                            k++;
                        }
                    }
                }
            }
        }
        if(sortedBoard.length==5) LOG.info("board sorted {} {} {} {} {}",sortedBoard[0],sortedBoard[1],sortedBoard[2],sortedBoard[3],sortedBoard[4]);
        if(sortedBoard.length==6) LOG.info("board sorted {} {} {} {} {} {}",sortedBoard[0],sortedBoard[1],sortedBoard[2],sortedBoard[3],sortedBoard[4],sortedBoard[5]);
        if(sortedBoard.length==7) LOG.info("board sorted {} {} {} {} {} {} {}",sortedBoard[0],sortedBoard[1],sortedBoard[2],sortedBoard[3],sortedBoard[4],sortedBoard[5],sortedBoard[6]);
        return sortedBoard;
    }

    public static String pairnessOfFlop (String[] flop){
        if(returnNumber(flop[0])==returnNumber(flop[1]) && returnNumber(flop[1])==returnNumber(flop[2])) return "Tripsed";
        if(returnNumber(flop[0])==returnNumber(flop[1]) || returnNumber(flop[1])==returnNumber(flop[2]) || returnNumber(flop[0])==returnNumber(flop[2]) ) return "Paired";
        return "Unpaired";
    }

    public static boolean handIsAPair (String[] hand){
        return (returnNumber(hand[0])==returnNumber(hand[1])) ;
    }


    public static String[] sortBoardPlusHand(String[] board, String[] hand){
        if(board.length==3) LOG.info("unisco questo board {} {} {}  con questa hand {} {} ",board[0],board[1],board[2],hand[0],hand[1]);
        if(board.length==4) LOG.info("unisco questo board {} {} {} {}  con questa hand {} {} ",board[0],board[1],board[2],board[3],hand[0],hand[1]);
        if(board.length==5) LOG.info("unisco questo board {} {} {} {} {} con questa hand {} {} ",board[0],board[1],board[2],board[3],board[4],hand[0],hand[1]);
        List<String> newBoardList = new ArrayList<>();
        for(String cardOfBoard : board){
            if(cardOfBoard!=null) newBoardList.add(cardOfBoard);
        }
        for(String cardOfHand : hand){
            if(cardOfHand!=null)newBoardList.add(cardOfHand);
        }
        String[] newBoardplusHandSorted = new String[newBoardList.size()];
        for(int i=0; i<newBoardList.size() ; i++){
            newBoardplusHandSorted[i]=newBoardList.get(i);
        }
        return sortBoard(newBoardplusHandSorted);
    }


    public static boolean boardContainThatCard(String[] board, String[] hand){
        for(String s : board){
            if(s!=null && ( (returnNumber(s)==returnNumber(hand[0])) || (returnNumber(s)==returnNumber(hand[1])) ) ) return true;
        }
        return false;
    }


    public static boolean boardIsOnlyPaired(String[] board){
        for(int i=0 ; i<board.length-1 ; i++) {
            int count = 0;
            for (int j = i + 1; j < board.length; j++) {
                if (returnNumber(board[i]) == returnNumber(board[j])) {
                    count++;
                }
            }
            if (count == 1) {
                LOG.info("Board is only paired!");
                return true;
            }
        }
        LOG.info("Board is not only paired!");
        return false;
    }

    public static boolean boardIsOnlyTripsed(String[] board){
        for(int i=0 ; i<board.length-1 ; i++) {
            int count = 0;
            for (int j = i + 1; j < board.length; j++) {
                if (returnNumber(board[i]) == returnNumber(board[j])) {
                    count++;
                }
            }
            if (count == 2) {
                LOG.info("Board is only tripsed!");
                return true;
            }
        }
            LOG.info("Board is not only tripsed!");
        return false;
    }

    public static boolean cardMakeAPairWithBoard(String[] board , String card){
        for(String cardOfBoard : board){
            if(returnNumber(card)==returnNumber(cardOfBoard)){
                LOG.info("la carta {} forma una coppia con il board {} {} {} {} {} ",card,board[0],board[1],board[2],board[3],board[4]);
                return true;
            }
        }
        LOG.info("la carta {} NON forma una coppia con il board {} {} {} {} {} ",card,board[0],board[1],board[2],board[3],board[4]);
        return false;
    }


    public static boolean cardMakeATripsWithBoard(String[] board , String card){
        int count=0;
        for(String cardOfBoard : board){
            if(returnNumber(card)==returnNumber(cardOfBoard)) count++;
        }
        if(count==2){
            LOG.info("la carta {} forma un trips con il board {} {} {} {} {} ",card,board[0],board[1],board[2],board[3],board[4]);
            return true;
        }
        LOG.info("la carta {} NON forma un trips con il board {} {} {} {} {} ",card,board[0],board[1],board[2],board[3],board[4]);
        return false;
    }



    public static boolean isFullHouseBoard(String[] board){
        if(board.length==5){
            HashMap<String,Integer> map = new HashMap<>();
            for(String s : board){
                if(!map.containsKey(s.substring(0,1))){
                    map.put(s.substring(0,1),1);
                }else{
                    int count=map.get(s.substring(0,1));
                    count++;
                    map.put(s.substring(0,1),count);
                }
            }
            if(map.size()==2){
                for(Map.Entry<String,Integer> entry : map.entrySet()){
                    if(entry.getValue()>1 && entry.getValue()<4 ) {
                        LOG.info("board is a fullHouse board");
                        return true;
                    }
                }
            }
        }
        LOG.info("board is not a fullHouse board");
        return false;
    }

    public static String[] getCardsPairedOnBoard(String[] board){
        if(boardIsOnlyPaired(board)){
            for(int i=0 ; i<board.length-1 ; i++){
                for(int j=i+1 ; j<board.length ; j++){
                    if(returnNumber(board[i])==returnNumber(board[j])){
                        LOG.info("le carte uguali del board sono {} {} {} ",board[i],board[j]);
                        return new String[]{board[i],board[j]};
                    }
                }
            }
        }
        return new String[1];
    }


    public static String[] getCardsTripsedOnBoard(String[] board) {
        if (boardIsOnlyTripsed(board)) {
            for (int i = 0; i < board.length - 2; i++) {
                for (int j = i + 1; j < board.length - 1; j++) {
                    if(returnNumber(board[i])==returnNumber(board[j])){
                        for (int k = j + 1; k < board.length; k++) {
                            if(returnNumber(board[j])==returnNumber(board[k])){
                                LOG.info("le carte del board che formano il trips sono {} {} {} ",board[i],board[j],board[k]);
                                return new String[]{board[i],board[j],board[k]};
                            }
                        }
                    }
                }
            }
        }
        return new String[1];
    }




        public static Integer returnNumber(String s) {
            String compare = s.substring(0,1);
            switch (compare) {
                case "A":
                    return 14;
                case "2":
                    return 2;
                case "3":
                    return 3;
                case "4":
                    return 4;
                case "5":
                    return 5;
                case "6":
                    return 6;
                case "7":
                    return 7;
                case "8":
                    return 8;
                case "9":
                    return 9;
                case "T":
                    return 10;
                case "J":
                    return 11;
                case "Q":
                    return 12;
                case "K":
                    return 13;
                default:
                    return null;
            }
        }

    public static Integer returnNumberALow(String s) {
        String compare = s.substring(0,1);
        switch (compare) {
            case "A":
                return 1;
            case "2":
                return 2;
            case "3":
                return 3;
            case "4":
                return 4;
            case "5":
                return 5;
            case "6":
                return 6;
            case "7":
                return 7;
            case "8":
                return 8;
            case "9":
                return 9;
            case "T":
                return 10;
            case "J":
                return 11;
            case "Q":
                return 12;
            case "K":
                return 13;
            default:
                return null;
        }
    }

    public static String returnCard(int i) {
        switch (i) {
            case 14:
                return "A";
            case 13:
                return "K";
            case 12:
                return "Q";
            case 11:
                return "J";
            case 10:
                return "T";
            default:
                return String.valueOf(i);
        }
    }

    public static String getFirstCard(String hand){
        return hand.substring(0,2);
    }

    public static String getSecondCard(String hand){
        return hand.substring(2,4);
    }

    public static Integer[] getPositionOfCardsPaired(String[] flop){
        if("Paired".equalsIgnoreCase(pairnessOfFlop(flop))){
            if(returnNumber(flop[0])==returnNumber(flop[1])) return new Integer[]{0,1};
            if(returnNumber(flop[0])==returnNumber(flop[2])) return new Integer[]{0,2};
            if(returnNumber(flop[1])==returnNumber(flop[2])) return new Integer[]{1,2};
        }
        return null;
    }

    public static Integer getPositionOfTheCardNotPaired(String[] flop){
        Integer[] positions = getPositionOfCardsPaired(flop);
        for(int i=0 ; i<flop.length ; i++){
            if(i!=positions[0] && i!=positions[1]) return i;
        }
        return null;
    }



}








